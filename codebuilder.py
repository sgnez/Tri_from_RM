

# This file was *autogenerated* from the file codebuilder.sage
from sage.all_cmdline import *   # import sage library

_sage_const_1 = Integer(1); _sage_const_21 = Integer(21); _sage_const_20 = Integer(20); _sage_const_2 = Integer(2); _sage_const_6 = Integer(6); _sage_const_0 = Integer(0); _sage_const_5 = Integer(5); _sage_const_8 = Integer(8); _sage_const_10000 = Integer(10000)
import copy
################################################################################
#                  INSTRUCTIONS FOR MODIFICATION OF THIS FILE                  #
################################################################################

#Modify this file as you wish, go to the folder containing this file, and run
# sage codebuilder.sage && mv codebuilder.sage.py codebuilder.py
# or 
# sagealone codebuilder.sage && mv codebuilder.sage.py codebuilder.py
#Reset the kernel for the modifications to reflect

################################################################################
#                             VARIABLE DEFINITIONS                             #
################################################################################

code = ''
for i in range(_sage_const_1 ,_sage_const_21 ):
    code+='x'+str(i)+'= var(\'x'+str(i)+'\')'
    if i<_sage_const_20 :
        code+='\n'
exec(code)

code = 'variables = ['
for i in range(_sage_const_1 ,_sage_const_21 ):
    code+='x'+str(i)
    if i<_sage_const_20 :
        code+=', '
code +=']'

exec(code)

# The following Ring variables are used when we specifically need to consier
# variables in the polynomial ring, not generic variables. It is slower and 
# is used rarely. See CPP_Representation and write_instuctions function below.

R1 = PolynomialRing(FiniteField(_sage_const_2 ), _sage_const_6 , names = ["y1","y2","y3","y4","y5","y6"])
y1,y2,y3,y4,y5,y6 = R1.gens()

Ring_Variables=[y1,y2,y3,y4,y5,y6]
################################################################################
#          FUNCTIONS THAT MAKE THE GENERATOR MATRIX FROM POLYNOMIALS           #
################################################################################

#Recursive function that efficiently generates the subspaces
def Rec_Gen_Maker(poly,num_var,depth,arr,G):
    if depth==num_var:
        if int(poly)%_sage_const_2 ==_sage_const_1 :
            G.append(([_sage_const_1 ]+arr).copy())
        return
    for i in range(_sage_const_2 ):
        arr[depth]=i
        Rec_Gen_Maker(poly.subs(variables[depth]==i),num_var,depth+_sage_const_1 ,arr,G)

#Returns the generator matrix
def Generator_Matrix(poly,num_var):
    arr=[_sage_const_0 ]*num_var
    G=[]
    Rec_Gen_Maker(poly, num_var, _sage_const_0 ,arr,G)
    G=matrix(G)
    G=G.transpose()
    return matrix(Integers(_sage_const_2 ),G)

################################################################################
#                    OUTPUTS THE WEIGHT ENUMERATOR FUNCTION                    #
################################################################################

def Weight_Enumerator(A):
    cols=A.ncols()
    rows=A.nrows()
    Prof=[_sage_const_0 ]*(cols+_sage_const_1 )
    num = _sage_const_0 
    for i in range(_sage_const_2 **rows):

        dig = num.digits(_sage_const_2 )
        num = num +_sage_const_1 
        dig = vector(dig + [_sage_const_0 ]*(rows-len(dig)))
        Prof[(dig*A).hamming_weight()]+=_sage_const_1 
    return Prof

################################################################################
#                    CHECKS IF A SUBSPACE IS TRIORTHOGONAL                     #
################################################################################

def Is_Tri(X):
    S = _sage_const_0 
    cs = X.ncols()
    for a in X:
        for b in X:
            for c in X:
                for i in range(cs):
                    S+=a[i]*b[i]*c[i]
                if (S%_sage_const_2 )==_sage_const_1 :
                    return False
    return True

################################################################################
#         THIS PART OF THE CODE GENERATES THE ODD AND EVEN DESCENDANTS         #
#          SEE THE MAIN JUPYTER NOTE BOOK FOR INSTRUCTIONS ON HOW TO           #
#                             USE THESE FUNCTIONS.                             #
################################################################################

#Recursive function that generates the triorthogonal matrices 
def Rec_Tri_Mat_Maker(G,c,k,depth,chosen,A,B,func,arg):
    if chosen>_sage_const_1 :
        if A.rank()<chosen:
            return False
    if depth==c:
        if chosen==k:            
            X=A.augment(B).echelon_form()
            X=X[:,k:]
#------------------------------------------------------------------------------#
# TODO: At this point the matrix X is a triorthogonal even descendants of a    #
#       the subspace G. We can do anything with X through the function f       #
#  We generically choose to check for distance                                 #
#  This part should be called through the Generate_Even_Desc(G,k,arg) function #
#  or the Generate_Odd_Desc(G,k,arg) function the input is passed over from    #
#  arg there                                                                   #
#  If returned "True", the search immediately ends
            return func(X,arg)
#------------------------------------------------------------------------------#
        return False
    
    if chosen<k:
        if type(A)==type([]):
            A=matrix(G.column(depth)).transpose()
            if Rec_Tri_Mat_Maker(G,c,k,depth+_sage_const_1 ,chosen+_sage_const_1 ,A,B,func,arg):
                return True
            A=[]
        else:
            A=A.augment(G.column(depth))
            if Rec_Tri_Mat_Maker(G,c,k,depth+_sage_const_1 ,chosen+_sage_const_1 ,A,B,func,arg):
                return True
            A=A.delete_columns([A.ncols()-_sage_const_1 ])
    
    if type(B)==type([]):
        B=matrix(G.column(depth)).transpose()
        if Rec_Tri_Mat_Maker(G,c,k,depth+_sage_const_1 ,chosen,A,B,func,arg):
            return True
        B=[]
    else:
        B=B.augment(G.column(depth))
        if Rec_Tri_Mat_Maker(G,c,k,depth+_sage_const_1 ,chosen,A,B,func,arg):
            return True
        B=B.delete_columns([B.ncols()-_sage_const_1 ])
    return False


#This function generates all even descendants of G with k logical variables, and runs the function 
# func on them with inputs func(X,arg), where X is the triorthogonal matrix
def Generate_Even_Desc(G,k,func,arg):
    c=G.ncols()
    A=[]
    B=[]
    return Rec_Tri_Mat_Maker(G,c,k,_sage_const_0 ,_sage_const_0 ,A,B,func,arg)

#This function generates all odd descendants of G with k logical variables, and runs the function 
# func on them with inputs func(X,arg), where X is the triorthogonal matrix
def Generate_Odd_Desc(G,k,func,arg):
    c=G.ncols()
    r=G.nrows()
    for marker in range(c):
        Desc = copy.copy(G)
        for i in range(_sage_const_1 ,r):
            if Desc[i,marker]==_sage_const_1 :
                Desc[i,:]+=Desc[_sage_const_0 ,:]
        rws = range(_sage_const_1 ,r)
        cls = [i for i in range(c) if i not in [marker]]
        Desc=Desc[rws,cls]
        #At this point, one row and one column is removed from Desc, it is sufficient to consider
        #  odd descendants of Desc
        if Generate_Even_Desc(Desc,k,func,arg):
            return True
    return False

################################################################################
#        FUNCTIONS FOR CHECKING THE DISTANCE OF A TRIORTHOGONAL MATRIX         #
################################################################################

#Recursive function for checking the distance
def Rec_Weight_Maker(G,k,s,d,chosen,marker,Vec):
    if marker+d-chosen>s:
        return True
    if chosen==d:
        col=G*Vec
        if not(col[_sage_const_0 :k].is_zero()) and col[k:].is_zero() == True:
            return False
        return True
    for i in range(marker,s):
        Vec[i]=_sage_const_1 
        if not(Rec_Weight_Maker(G,k,s,d,chosen+_sage_const_1 ,i+_sage_const_1 ,Vec)):
            return False
        Vec[i]=_sage_const_0 
    return True

#The following function returns true if the distance of Desc with k logical 
#qubits is larger than d
def Is_Dist_Larger(Desc, d):
    s=Desc.ncols()
    k=sum(Desc.columns()).hamming_weight()
    Vec=vector(Integers(_sage_const_2 ),[_sage_const_0 ]*s)
    return Rec_Weight_Maker(Desc,k,s,d,_sage_const_0 ,_sage_const_0 ,Vec)

################################################################################
#                   FUNCTIONS USED FOR TALKING TO C++ CODES                    #
################################################################################

def CPP_Representation(poly):
    base=[]
    for monomial in poly.monomials():
        num = _sage_const_0 
        for i in range(_sage_const_6 ):
            num*=_sage_const_2 
            if monomial.degree(Ring_Variables[_sage_const_5 -i])>_sage_const_0 :
                num+=_sage_const_1 
        base.append(num)
    return base

#The following function writes the base pairs in the 
# "poly_finder_instructions.txt" file which is the input of the fast parallel 
# C++ code for finding the affine equivalence classes of polynomials.

#base_pairs is an array of all base pairs, where the input is in the in terms
# of ring variables y1,..., y6.
#weight is the target weight.
#number_of_threads is the number of cpu threads used.
#trigger_wait & trigger_random_jumps & max_number_polys -> see the C++ code 
# for detailed and explanation. It is ususally fine to use the default values.


def write_instuctions(base_pairs,weight,number_of_threads=_sage_const_8 , trigger_wait=_sage_const_1 ,
                              trigger_random_jumps=_sage_const_0 , max_number_polys=_sage_const_10000 ):
    file = open("poly_finder_instructions.txt", "w")
    num_bases = len(base_pairs)
    file.write(str(weight)+"\n");
    file.write(str(num_bases)+"\n");
    file.write(str(number_of_threads)+"\n");
    file.write(str(trigger_wait)+"\n");
    file.write(str(trigger_random_jumps)+"\n");
    file.write(str(max_number_polys)+"\n");
    for [pbase1,pbase2] in base_pairs:
        base1=CPP_Representation(pbase1)
        base2=CPP_Representation(pbase2)
        file.write(str(len(base1))+'\n')
        for x in base1:
            file.write(str(x)+'\n')
        file.write(str(len(base2))+'\n')
        for x in base2:
            file.write(str(x)+'\n') 
    file.close()



